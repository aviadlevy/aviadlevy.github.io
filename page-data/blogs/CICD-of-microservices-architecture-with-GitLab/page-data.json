{"componentChunkName":"component---src-templates-nodes-js","path":"/blogs/CICD-of-microservices-architecture-with-GitLab/","result":{"data":{"site":{"siteMetadata":{"title":"Aviad Levy"}},"markdownRemark":{"id":"3145f6d7-429e-5581-9d3b-b16411d2ed2c","excerpt":"CI/CD of microservices architecture with GitLab How we made our microservices continuous integration & delivery process easily maintained This is a re-publish…","html":"<h1>CI/CD of microservices architecture with GitLab</h1>\n<h2>How we made our microservices continuous integration &#x26; delivery process easily maintained</h2>\n<blockquote>\n<p>This is a re-publish for a post I wrote back in Aug 2019. many things changed since then and I hope to write new post about it soon</p>\n</blockquote>\n<p>As the Threat Cloud Application team, we’re responsible for many cloud applications. We have public applications, and many other internal applications that support them. This software design is also known as a microservices architecture. Our applications are deployed on Kubernetes cluster which is deployed in AWS.</p>\n<p>We started using GitLab as our central source code management and application life cycle about a year ago.</p>\n<p>In this post I’ll describe our evolution of understanding how to work with GitLab in order to easily maintain the life cycle of our microservices.</p>\n<h1>What we had when we began</h1>\n<p>When we joined our internal hosted GitLab our main focus was to simply import all of our code base from a simple git server to GitLab. We didn’t fully invest in exploring the many ways GitLab can help us in the development cycle and the CI/CD process.</p>\n<p>It wasn’t long before we began designing our CI/CD process, but even then we didn’t fully capitalize the GitLab features and our .gitlab-ci.yml looked like this:</p>\n<pre><code class=\"language-yaml\">image: docker:latest\nservices:\n- docker:dind\n\nstages:\n- build\n- integration-test\n- push\n- dev-deploy\n- prod-deploy\n\n# Cache downloaded dependencies and plugins between builds.\ncache:\n  paths:\n  - .m2/repository\n  key: \"$CI_JOB_NAME\"\n\nvariables:\n  CONTAINER_RELEASE_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n  CONTAINER_RELEASE_IMAGE_LATEST: $CI_REGISTRY_IMAGE:latest\n  DEV_KUBECTL_CONFIG: $k8s_deploy_config_kube1\n  EU_PROD_KUBECTL_CONFIG: $k8s_deploy_config_eu_west_1_kube2\n  US_PROD_KUBECTL_CONFIG: $k8s_deploy_config_us_east_1_kube1\n  MAVEN_OPTS: \"-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository\"\n\n\nmaven-build:\n  image: snirnx/docker-maven:3.5.4\n  stage: build\n  script:\n  - \"sh ci_scripts/run_build.sh dev jar\"\n  except:\n    - master\n\nmaven-build-master:\n  image: snirnx/docker-maven:3.5.4\n  stage: build\n  script:\n  - \"sh ci_scripts/run_build.sh master jar\"\n  only:\n    - master\n\nintegration:\n  image: snirnx/docker-maven:3.5.4\n  stage: integration-test\n  script:\n    - \"bash ci_files/integration_test.sh $CI_COMMIT_SHA\"\n  artifacts:\n    name: \"CI_COMMIT_SHA-results\"\n    when: always\n    expire_in: 4 days\n    paths:\n      - reputation-service-integration-tests/target/site/\n      - reputation-service-integration-tests/log/\n  tags:\n    - reputation-integration-tests\n\n\ndevelopment-deploy:\n  stage: dev-deploy\n  image: snirnx/kubectl:v1.8.6\n  script:\n  - \"sh ci_scripts/deploy.sh dev eu\"\n  only:\n  - master\n\nproduction-deploy:\n  stage: prod-deploy\n  image: snirnx/kubectl:v1.8.6\n  script:\n  - \"sh ci_scripts/deploy.sh prod us\"\n  - \"sh ci_scripts/deploy.sh prod eu\"  \n  only:\n  - master\n  when: manual\n</code></pre>\n<p>As we can see, the pipeline was depend fully on old-style bash scripts.</p>\n<pre><code class=\"language-bash\">ENV=$1\nAPP=$2\nPACKAGE=$3\n\nmvn clean install\nrc=$?\nif [[ $rc -ne 0 ]]; then\n  echo \"Maven build failed\"; exit $rc\nfi\n\ncp target/$APP.$PACKAGE docker/\n\ndocker build -t $APP docker/\n\ndocker images\n\n#echo \"docker login\"\ndocker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n\necho \"docker tag\"\ndocker tag $APP $CI_REGISTRY_IMAGE/$APP:$CI_COMMIT_SHA\nif [[ \"$ENV\" != \"dev\" ]]; then\n    docker tag $APP $CI_REGISTRY_IMAGE/$APP:latest\nfi\n\n#echo \"docker push\"\ndocker push $CI_REGISTRY_IMAGE/$APP:$CI_COMMIT_SHA\nif [[ \"$ENV\" != \"dev\" ]]; then\n    docker push $CI_REGISTRY_IMAGE/$APP:latest\nfi\n\nrc=$?\nif [[ $rc -ne 0 ]]; then\n  echo \"Failed to push to regsitry $APP\"; exit $rc\nfi\n\n\necho \"Pushed build '$CI_REGISTRY_IMAGE/$APP:$CI_COMMIT_SHA'\"\n</code></pre>\n<p>One big downside of using this kind of scripts inside .gitlab-ci.yml job was that we needed to handle exit code of each ourselves, or else the job won’t fail when one step is failed. Other downside was that GitLab didn’t highlight each step from within a single script, so we needed to handle it ourselves using echo commands.</p>\n<p>The only thing we considered as an advantage was the ability to copy the generic bash script between the different projects, allowing our developers to focus on the code of the new microservice application and not on the CI process. Or so we thought. But what happen when you want to improve something in your CI bash scripts? Add a new feature? Going over ~30 repositories is not an easy thing.</p>\n<p>One solution was to keep one scripts project in GitLab with all the bash scripts allowing each project to clone and use the script it requires. Even though this is good enough solution, we knew there had to be more native GitLab way to handle centralize CI/CD pipeline.</p>\n<h1>What we have now</h1>\n<p>We start using a feature introduced as a Premium feature on the GitLab 10.5 and moved to GitLab core on 11.4 release. The feature is called include.</p>\n<blockquote>\n<p>Using the include keyword, you can allow the inclusion of external YAML file</p>\n</blockquote>\n<p>With this feature our .gitlab-ci.yml looks like this:</p>\n<pre><code class=\"language-yaml\">image: docker:latest\nservices:\n  - docker:dind\n\nstages:\n  - build\n  - integration-test\n  - pre-dev-deploy\n  - dev-deploy\n  - continue-to-prod\n  - pre-prod-deploy\n  - prod-deploy\n  - post-deploy\n\n# Cache downloaded dependencies and plugins between builds.\ncache:\n  paths:\n    - .m2/repository\n  key: \"$CI_JOB_NAME\"\n\nvariables:\n  IMAGE_NAME: \"image-name\"\n  DOCKER_FILE_DIR: docker/\n  K8S_DEV_CONFIGMAP: \"\"\n  K8S_PROD_CONFIGMAP: \"\"\n  K8S_DEV_DEPLOYMENT: \"k8s/dev/deployment.yaml\"\n  K8S_PROD_DEPLOYMENT: \"k8s/prod/deployment.yaml\"\n\ninclude:\n  - project: \"ThreatCloud/centralize-reputation-pipeline\"\n    file: .gitlab-ci-build-mvn.yml\n  - project: \"ThreatCloud/centralize-reputation-pipeline\"\n    file: .gitlab-ci-integration.yml\n  - project: \"ThreatCloud/centralize-reputation-pipeline\"\n    file: .gitlab-ci-deploy.yml\n  - project: \"ThreatCloud/centralize-reputation-pipeline\"\n    file: .gitlab-ci-post.yml\n\n</code></pre>\n<p>The first thing we did was to define what stages we wanted to be included in our pipeline for all our applications:</p>\n<ul>\n<li><strong>Build</strong> — Run unit tests, dockerize the service and also test that the yamls of the deployments are valid</li>\n<li><strong>Integration Tests</strong> — Run the integration test for each service</li>\n<li><strong>Pre Staging deployment</strong> — Things needed to be deployed in the staging k8s before deploying the actual service, e.g. configmap</li>\n<li><strong>Staging deployment</strong> — Deploying the service to staging k8s</li>\n<li><strong>Pre Production deployment</strong> — Things needed to be deployed in the production k8s before deploying the actual service, e.g. configmap</li>\n<li><strong>Production deployment</strong> — Deploying the service to production k8s</li>\n<li><strong>Post Production deployment</strong> — Things we’re doing after each production deployment, e.g. notify to slack about the deployment and release changes</li>\n</ul>\n<p>Then we built .gitlab-ci.yml files for all steps. We made sure to keep it generic so that only by using different variables defined in each project the pipeline would work as expected.</p>\n<p>Now we can enjoy a native GitLab CI execution and highlight in all of our jobs. We can easily add new features to each step and automatically all the projects will start enjoying it automatically. The developer doesn’t need to deal with the CI/CD process and can focus solely on writing new code. All he needs to do is to copy the .gitlab-ci.yml, change a few variable and that’s it, the pipeline works.</p>\n<h1>Conclusion</h1>\n<p>In this post I tried, as simple as possible, to describe the process we went through to successfully maintain our CI/CD pipelines with GitLab. I’m sure that there are other solutions and ways that GitLab can help improve an application life cycle.</p>\n<p>I hope that you found this tutorial helpful. Thanks for reading!</p>\n<blockquote>\n<p>To see how we further improved our CI/CD process with GitLab, check out <a href=\"https://medium.com/@aviadlevy/ci-cd-of-microservices-architecture-with-gitlab-pt-2-f640d4c57c9b\">part 2</a></p>\n</blockquote>","frontmatter":{"title":"","emoji":null,"subtitlePrefix":null,"subtitleHighlight":null,"subtitleSuffix":null,"slug":null}}},"pageContext":{"id":"3145f6d7-429e-5581-9d3b-b16411d2ed2c"}},"staticQueryHashes":["1947816842","2841359383"]}