{"componentChunkName":"component---src-templates-nodes-js","path":"/blogs/CICD-of-microservices-architecture-with-GitLab-—-Pt.-2/","result":{"data":{"site":{"siteMetadata":{"title":"Aviad Levy"}},"markdownRemark":{"id":"ee8d16b2-9b61-57d4-8947-e93276518351","excerpt":"CI/CD of microservices architecture with GitLab — Pt. 2 How we used GitLab‘s dynamic child pipelines to maintain and expand our services to many regions This…","html":"<h1>CI/CD of microservices architecture with GitLab — Pt. 2</h1>\n<h2>How we used GitLab‘s dynamic child pipelines to maintain and expand our services to many regions</h2>\n<blockquote>\n<p>This part describes how we expand and improve our CI.<br>\nFor part 1 — <a href=\"https://medium.com/@aviadlevy/ci-cd-of-microservices-architecture-with-gitlab-bebce3735ccd\">https://medium.com/@aviadlevy/ci-cd-of-microservices-architecture-with-gitlab-bebce3735ccd</a></p>\n</blockquote>\n<p>In the previous blog post I described how we used GitLab CI features to easily maintain many microservices life cycle — from packaging to delivering. We packaged the code in docker container, fully tested the docker image and deployed it to AWS EKS cluster.</p>\n<p>As we continued growing and wanted to expand to new AWS regions, we’ve encountered a new challenge. In the next sections I’ll describe the challenge and how we solved it.</p>\n<h1>The Challenge</h1>\n<p>At the time, on each microservice project we kept its own k8s’ deployment configurations per site, so if we wanted to add a new region we needed to add another deployment configuration per each new environment for each microservice project. When you’re dealing with ~80 microservices it can take a lot of time.</p>\n<p>So the first thing we understood very fast was that we need to centralize our k8s configurations in one repository which will control everything. But if we want to initiate a new region we’ll have to create, for each microservice, its own new k8s configuration for the new region. Also in order to control which microservice to deploy on each region we’ll have to hold a very long <code>.gitlab-ci.yaml</code> with job for each microservice per each region, with specific <code>rules — changes:</code> which makes the maintenance for the CI very hard.</p>\n<p><em>We wanted to do better.</em></p>\n<h1>How We Solved It</h1>\n<p>First thing we did was to “generalize” our k8s configuration. we want to maintain one k8s deployment configuration, and control the difference between the clusters programmatically (with simple search and replace for anchors)</p>\n<p>Here is an example of a “generic” k8s deployment configuration (the anchors are <code>{{NAMESPACE}}</code> and <code>{{ECR_REGION}}</code>)</p>\n<pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: app-xx\n  name: app-xx\n  namespace: {{NAMESPACE}}\nspec:...\n    spec:\n      containers:\n        - name: app-xx\n          image: xxxxxxxx.dkr.ecr.{{ECR_REGION}}.amazonaws.com/group/app-xx:latest\n          imagePullPolicy: IfNotPresent\n          env:\n...\n      nodeSelector:\n        node-role/nodes-{{NAMESPACE}}: \"true\"\n      tolerations:\n        - effect: NoSchedule\n          key: dedicated\n          operator: Equal\n          value: nodes-{{NAMESPACE}}\n        - effect: NoExecute\n          key: dedicated\n          operator: Equal\n          value: nodes-{{NAMESPACE}}\n</code></pre>\n<p>This helps us to maintain only one deployment for each microservices, and all other regions that will be added in the future will also use this deployment configuration.</p>\n<p>In order to use small maintainable <code>.gitlab-ci.yaml</code> we started using a feature introduced as a in GitLab on version 12.9 — “<a href=\"https://docs.gitlab.com/ee/ci/pipelines/parent_child_pipelines.html#dynamic-child-pipelines\">Dynamic child pipelines</a>”.</p>\n<blockquote>\n<p>Instead of running a child pipeline from a static YAML file, you can define a job that runs your own script to generate a YAML file, which is then used to trigger a child pipeline.</p>\n</blockquote>\n<p>This feature allows us to create <code>.gitlab-ci.yaml</code> configuration from script and template and then run it as child pipeline.</p>\n<p>This is how the <code>.gitlab-ci.yaml</code> looks:</p>\n<pre><code class=\"language-yaml\">image: $CI_REGISTRY_IMAGE/$CI_IMAGE_NAME:latest\nservices:\n  - docker:dind\n\nstages:\n  - generate-ci\n  - triggers\n\ngenerate-ci:\n  stage: generate-ci\n  script:\n    - python3 scripts/generate_ci.py\n  artifacts:\n    paths:\n      - ci-out\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"\n      when: never\n    - when: always\n\nparents:\n  stage: triggers\n  trigger:\n    include:\n      - artifact: ci-out/middle-ci.yml\n        job: generate-ci\n    strategy: depend\n  variables:\n    PARENT_PIPELINE_ID: $CI_PIPELINE_ID\n    PARENT_JOB_NAME: generate-ci\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"\n      when: never\n    - when: always\n</code></pre>\n<p>On <code>generate-ci</code> stage we’re using a simple python script. The script gets only the relevant git changes and dynamically builds the <code>middle-ci.yaml</code> file. Then, the <code>parents</code> stage will use this file and will run the necessary stages to update deployment configuration with the matching GitLab’s environment variables.</p>\n<p>This is the <a href=\"https://pypi.org/project/Jinja2/\">Jinja</a> template we’re using:</p>\n<pre><code class=\"language-yaml\">\nimage: gitlab.locsec.net:4567/cloudmta/threatcloud-mta-infra/ci-image:latest\n# https://docs.gitlab.com/ee/ci/yaml/index.html#switch-between-branch-pipelines-and-merge-request-pipelines\nworkflow:\n  rules:\n    - if: $CI_COMMIT_BRANCH &#x26;&#x26; $CI_OPEN_MERGE_REQUESTS &#x26;&#x26; $CI_PIPELINE_SOURCE == \"push\"\n      when: never\n    - when: always\n\nvariables:\n  PY_COLORS: '1'\n  GIT_SUBMODULE_STRATEGY: recursive\n\nstages:\n{% for environment in environments.keys() %}\n  - \"validate:{{ environment }}:{{ stage_params[1:] |join('-') }}\"\n  - \"deploy:{{ environment }}:{{ stage_params[1:] |join('-') }}\"\n{% endfor %}\n\n{% for stage in [\"validate\", \"deploy\"] %}\n{% for environment, regions in environments.items() %}\n{% for region in regions %}\n{{ stage }}:{{ resource }}:{{ environment }}:{{ region }}:{{ stage_params[1:] |join('-') }}:\n{% if stage == \"deploy\" %}\n  rules:\n    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n      when: never\n{% if ci_project_name == \"app-infra\" %}\n    - when: manual\n{% else %}\n    - when: on_success\n{% endif %}\n  environment:\n    name: {{ stage_params[1:] |join('-') }}/{{ resource }}/{{ environment }}/{{ region }}\n{% endif %}\n  variables:\n    AWS_ACCESS_KEY_ID: ${{ region | upper | replace(\"-\", \"_\") }}_{{ environment | upper }}_STS_KEY\n    AWS_SECRET_ACCESS_KEY: ${{ region | upper | replace(\"-\", \"_\") }}_{{ environment | upper }}_STS_SECRET\n    CLUSTER_NAME: {{ region }}-{{ \"prd\" if environment == \"prod\" else environment }}\n    K8S_NAMESPACE: group-{{ \"dev\" if environment == \"stg\" else environment }}\n    AWS_REGION: {{ region }}\n  stage: {{ stage }}:{{ environment }}:{{ stage_params[1:] |join('-') }}\n  allow_failure: false\n  script:\n{% if ci_project_name != \"app-infra\" %}\n    - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.locsec.net/group/app-infra.git\n    - cd app-infra\n{% endif %}\n    - aws --region $AWS_REGION eks update-kubeconfig --name $CLUSTER_NAME\n    - kubectl config set-context --current --namespace=$K8S_NAMESPACE\n    - python3 scripts/apply_k8s.py --file {{ file }} --resource {{ resource }} --environment {{ environment }} --region {{ region }} --stage {{ stage }}\n{% endfor %}\n{% endfor %}\n{% endfor %}\n</code></pre>\n<p>You can see in the example where the “magic” is hidden. In the <code>variables</code> section we have our AWS environment variable, which is needed to deploy our app to the EKS cluster. This environment is built from the template <code>${{ region | upper | replace(“-”, “_”) }}_{{ environment | upper }}_STS_KEY</code>.</p>\n<p>Here is an output example from this template:</p>\n<pre><code class=\"language-yaml\">\nimage: gitlab.locsec.net:4567/cloudmta/threatcloud-mta-infra/ci-image:latest\n# https://docs.gitlab.com/ee/ci/yaml/index.html#switch-between-branch-pipelines-and-merge-request-pipelines\nworkflow:\n  rules:\n    - if: $CI_COMMIT_BRANCH &#x26;&#x26; $CI_OPEN_MERGE_REQUESTS &#x26;&#x26; $CI_PIPELINE_SOURCE == \"push\"\n      when: never\n    - when: always\nvariables:\n  PY_COLORS: '1'\n  GIT_SUBMODULE_STRATEGY: recursive\n\nstages:\n  - \"validate:stg:app-config-service\"\n  - \"deploy:stg:app-config-service\"\n  - \"validate:prod:app-config-service\"\n  - \"deploy:prod:app-config-service\"\n\n\n\nvalidate:deployment:stg:eu-west-1:app-config-service:\n  variables:\n    AWS_ACCESS_KEY_ID: $EU_WEST_1_STG_STS_KEY\n    AWS_SECRET_ACCESS_KEY: $EU_WEST_1_STG_STS_SECRET\n    CLUSTER_NAME: eu-west-1-group-stg\n    K8S_NAMESPACE: group-stg\n    AWS_REGION: eu-west-1\n  stage: validate:stg:app-config-service\n  allow_failure: false\n  script:\n    - aws --region $AWS_REGION eks update-kubeconfig --name $CLUSTER_NAME\n    - kubectl config set-context --current --namespace=$K8S_NAMESPACE\n    - python3 scripts/apply_k8s.py --file k8s/app-config-service/deployment.yaml --resource deployment --environment stg --region eu-west-1 --stage validate\n\nvalidate:deployment:prod:us-east-1:app-config-service:\n  variables:\n    AWS_ACCESS_KEY_ID: $US_EAST_1_PROD_STS_KEY\n    AWS_SECRET_ACCESS_KEY: $US_EAST_1_PROD_STS_SECRET\n    CLUSTER_NAME: us-east-1-group-prd\n    K8S_NAMESPACE: group-prod\n    AWS_REGION: us-east-1\n  stage: validate:prod:app-config-service\n  allow_failure: false\n  script:\n    - aws --region $AWS_REGION eks update-kubeconfig --name $CLUSTER_NAME\n    - kubectl config set-context --current --namespace=$K8S_NAMESPACE\n    - python3 scripts/apply_k8s.py --file k8s/app-config-service/deployment.yaml --resource deployment --environment prod --region us-east-1 --stage validate\n\n\ndeploy:deployment:stg:eu-west-1:app-config-service:\n  rules:\n    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n      when: never\n    - when: manual\n  environment:\n    name: app-config-service/deployment/stg/eu-west-1\n  variables:\n    AWS_ACCESS_KEY_ID: $EU_WEST_1_STG_STS_KEY\n    AWS_SECRET_ACCESS_KEY: $EU_WEST_1_STG_STS_SECRET\n    CLUSTER_NAME: eu-west-1-group-stg\n    K8S_NAMESPACE: group-dev\n    AWS_REGION: eu-west-1\n  stage: deploy:stg:app-config-service\n  allow_failure: false\n  script:\n    - aws --region $AWS_REGION eks update-kubeconfig --name $CLUSTER_NAME\n    - kubectl config set-context --current --namespace=$K8S_NAMESPACE\n    - python3 scripts/apply_k8s.py --file k8s/app-config-service/deployment.yaml --resource deployment --environment stg --region eu-west-1 --stage deploy\n\ndeploy:deployment:prod:us-east-1:app-config-service:\n  rules:\n    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n      when: never\n    - when: manual\n  environment:\n    name: app-config-service/deployment/prod/us-east-1\n  variables:\n    AWS_ACCESS_KEY_ID: $US_EAST_1_PROD_STS_KEY\n    AWS_SECRET_ACCESS_KEY: $US_EAST_1_PROD_STS_SECRET\n    CLUSTER_NAME: us-east-1-group-prd\n    K8S_NAMESPACE: group-prod\n    AWS_REGION: us-east-1\n  stage: deploy:prod:app-config-service\n  allow_failure: false\n  script:\n    - aws --region $AWS_REGION eks update-kubeconfig --name $CLUSTER_NAME\n    - kubectl config set-context --current --namespace=$K8S_NAMESPACE\n    - python3 scripts/apply_k8s.py --file k8s/app-config-service/deployment.yaml --resource deployment --environment prod --region us-east-1 --stage deploy\n</code></pre>\n<p>Adding a new region, to deploy all our microservices, is as easy as adding a Gitlab’s group environment variable!</p>\n<p>This is how the pipeline will look on the centralize k8s configuration project:</p>\n<p><img src=\"https://miro.medium.com/max/875/1*lG8gvALfRfZRNmPPlcZuuw.png\" alt=\"\"></p>\n<p>dynamic child pipelines</p>\n<p>From each project, we’ll use this stages to deploy only the specific microservice:</p>\n<pre><code class=\"language-yaml\">\ncreate deploy to dedicated prod:\n  stage: pre-prod-deploy\n  image: gitlab.locsec.net:4567/group/app-infra/ci-image:latest\n  script:\n    - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.locsec.net/group/app-infra.git\n    - cd app-infra\n    - python3 scripts/generate_ci.py\n    - cp -r ci-out ..\n  artifacts:\n    paths:\n      - ci-out\n  except:\n    refs:\n      - schedules\n  only:\n    refs:\n      - master\n\n\ndeploy to dedicated prod:\n  stage: prod-deploy\n  variables:\n    PARENT_PIPELINE_ID: $CI_PIPELINE_ID\n    PARENT_JOB_NAME: \"create deploy to dedicated prod\"\n  trigger:\n    include:\n      - artifact: ci-out/middle-ci.yml\n        job: \"create deploy to dedicated prod\"\n    strategy: depend\n  when: on_success\n  except:\n    refs:\n      - schedules\n  only:\n    refs:\n      - master\n</code></pre>\n<p>That’s it. we can now easily maintain our k8s configurations, our deployment CI and initiate new regions.</p>\n<h1>Conclusion</h1>\n<p>In this post I continued describing how GitLab CI helps us with our app growth. I tried to keep it as simple as possible, but if something is not clear enough, feel free to contact me with any question you have.</p>\n<p>I hope you found this tutorial helpful. Thanks for reading!</p>\n<blockquote>\n<p>Thanks a lot to <a href=\"https://medium.com/@israelst11\">Israelst</a> for reviewing this post</p>\n</blockquote>","frontmatter":{"title":"","emoji":null,"subtitlePrefix":null,"subtitleHighlight":null,"subtitleSuffix":null,"slug":null}}},"pageContext":{"id":"ee8d16b2-9b61-57d4-8947-e93276518351"}},"staticQueryHashes":["1947816842","2841359383"]}