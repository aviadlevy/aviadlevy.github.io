{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"template":{"edges":[{"node":{"frontmatter":{"title":"Blogs","emoji":"","subtitlePrefix":"My","subtitleHighlight":"blog posts","subtitleSuffix":"are listed below","slug":"blogs"},"html":"<a href=\"/blogs/CICD-of-microservices-architecture-with-GitLab\" style=\"display: inherit\">\n<div class=\"card\"> \n<h2>CI/CD of microservices architecture with GitLab</h2>\n<h3>How we made our microservices continuous integration &#x26; delivery process easily maintained</h3>\n</div></a>\n<a href=\"/blogs/CICD-of-microservices-architecture-with-GitLab-‚Äî-Pt.-2/\" style=\"display: inherit\">\n<div class=\"card\"> \n<h2>CI/CD of microservices architecture with GitLab ‚Äî Pt. 2</h2>\n<h3>How we used GitLab‚Äòs dynamic child pipelines to maintain and expand our services to many regions</h3>\n</div>\n</a>\n<a href=\"/blogs/How-to-Install-go-yara-Library-on-Windows/\" style=\"display: inherit\">\n<div class=\"card\"> \n<h2>How to Install go-yara Library on Windows</h2>\n<h3>Installing go-yara library on Windows using MSYS2 and MinGW.</h3>\n</div>\n</a>"}},{"node":{"frontmatter":{"title":"Projects","emoji":"","subtitlePrefix":"My","subtitleHighlight":"projects","subtitleSuffix":"are listed below","slug":"projects"},"html":"<div class=\"card\"> \n<h2>Plant Generator</h2>\n<ul>\n<li><a href=\"/projects/plant-generator\" class=\"projects\">Try it now</a></li>\n<li>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/aviadlevy/plant-generator\" class=\"projects\">\nSource Code</a>\n</li>\n</ul>\n</div>\n<div class=\"card\"> \n<h2>Hebrew Year Process Bot</h2>\n<h4>This bot publish the progress of the Hebrew calendar year.</h4>\n<ul>\n<li>\n<h3><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://twitter.com/yearProgressHeb\" class=\"projects\">Twitter</a></h3>\n  <div class=\"center\">\n  <blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"und\" dir=\"ltr\">‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 43%</p>&mdash; Hebrew Year Progress (@yearProgressHeb) <a href=\"https://twitter.com/yearProgressHeb/status/1099773897254359040?ref_src=twsrc%5Etfw\">February 24, 2019</a></blockquote>\n  </div>\n</li>\n<li>\n<h3><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://mastodon.social/@yearProgressHeb\" class=\"projects\">Mastodon</a></h3>\n  <div class=\"center\">\n  <blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"und\" dir=\"ltr\">‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 17%</p>&mdash; Hebrew Year Progress (@yearProgressHeb) <a href=\"https://mastodon.social/@yearProgressHeb/113585373770390214\">Dec 02, 2024</a></blockquote>\n  </div>\n</li>\n</ul>\n<br/>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/aviadlevy/hebrew-year-process-bot\" class=\"projects\">Source Code</a>\n</div>"}},{"node":{"frontmatter":{"title":"","emoji":null,"subtitlePrefix":null,"subtitleHighlight":null,"subtitleSuffix":null,"slug":null},"html":"<h1>CI/CD of microservices architecture with GitLab ‚Äî Pt. 2</h1>\n<h2>How we used GitLab‚Äòs dynamic child pipelines to maintain and expand our services to many regions</h2>\n<blockquote>\n<p>This part describes how we expand and improve our CI.<br>\nFor part 1 ‚Äî <a href=\"https://medium.com/@aviadlevy/ci-cd-of-microservices-architecture-with-gitlab-bebce3735ccd\">https://medium.com/@aviadlevy/ci-cd-of-microservices-architecture-with-gitlab-bebce3735ccd</a></p>\n</blockquote>\n<p>In the previous blog post I described how we used GitLab CI features to easily maintain many microservices life cycle ‚Äî from packaging to delivering. We packaged the code in docker container, fully tested the docker image and deployed it to AWS EKS cluster.</p>\n<p>As we continued growing and wanted to expand to new AWS regions, we‚Äôve encountered a new challenge. In the next sections I‚Äôll describe the challenge and how we solved it.</p>\n<h1>The Challenge</h1>\n<p>At the time, on each microservice project we kept its own k8s‚Äô deployment configurations per site, so if we wanted to add a new region we needed to add another deployment configuration per each new environment for each microservice project. When you‚Äôre dealing with ~80 microservices it can take a lot of time.</p>\n<p>So the first thing we understood very fast was that we need to centralize our k8s configurations in one repository which will control everything. But if we want to initiate a new region we‚Äôll have to create, for each microservice, its own new k8s configuration for the new region. Also in order to control which microservice to deploy on each region we‚Äôll have to hold a very long <code>.gitlab-ci.yaml</code> with job for each microservice per each region, with specific <code>rules ‚Äî changes:</code> which makes the maintenance for the CI very hard.</p>\n<p><em>We wanted to do better.</em></p>\n<h1>How We Solved It</h1>\n<p>First thing we did was to ‚Äúgeneralize‚Äù our k8s configuration. we want to maintain one k8s deployment configuration, and control the difference between the clusters programmatically (with simple search and replace for anchors)</p>\n<p>Here is an example of a ‚Äúgeneric‚Äù k8s deployment configuration (the anchors are <code>{{NAMESPACE}}</code> and <code>{{ECR_REGION}}</code>)</p>\n<pre><code class=\"language-yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: app-xx\n  name: app-xx\n  namespace: {{NAMESPACE}}\nspec:...\n    spec:\n      containers:\n        - name: app-xx\n          image: xxxxxxxx.dkr.ecr.{{ECR_REGION}}.amazonaws.com/group/app-xx:latest\n          imagePullPolicy: IfNotPresent\n          env:\n...\n      nodeSelector:\n        node-role/nodes-{{NAMESPACE}}: \"true\"\n      tolerations:\n        - effect: NoSchedule\n          key: dedicated\n          operator: Equal\n          value: nodes-{{NAMESPACE}}\n        - effect: NoExecute\n          key: dedicated\n          operator: Equal\n          value: nodes-{{NAMESPACE}}\n</code></pre>\n<p>This helps us to maintain only one deployment for each microservices, and all other regions that will be added in the future will also use this deployment configuration.</p>\n<p>In order to use small maintainable <code>.gitlab-ci.yaml</code> we started using a feature introduced as a in GitLab on version 12.9 ‚Äî ‚Äú<a href=\"https://docs.gitlab.com/ee/ci/pipelines/parent_child_pipelines.html#dynamic-child-pipelines\">Dynamic child pipelines</a>‚Äù.</p>\n<blockquote>\n<p>Instead of running a child pipeline from a static YAML file, you can define a job that runs your own script to generate a YAML file, which is then used to trigger a child pipeline.</p>\n</blockquote>\n<p>This feature allows us to create <code>.gitlab-ci.yaml</code> configuration from script and template and then run it as child pipeline.</p>\n<p>This is how the <code>.gitlab-ci.yaml</code> looks:</p>\n<pre><code class=\"language-yaml\">image: $CI_REGISTRY_IMAGE/$CI_IMAGE_NAME:latest\nservices:\n  - docker:dind\n\nstages:\n  - generate-ci\n  - triggers\n\ngenerate-ci:\n  stage: generate-ci\n  script:\n    - python3 scripts/generate_ci.py\n  artifacts:\n    paths:\n      - ci-out\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"\n      when: never\n    - when: always\n\nparents:\n  stage: triggers\n  trigger:\n    include:\n      - artifact: ci-out/middle-ci.yml\n        job: generate-ci\n    strategy: depend\n  variables:\n    PARENT_PIPELINE_ID: $CI_PIPELINE_ID\n    PARENT_JOB_NAME: generate-ci\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"\n      when: never\n    - when: always\n</code></pre>\n<p>On <code>generate-ci</code> stage we‚Äôre using a simple python script. The script gets only the relevant git changes and dynamically builds the <code>middle-ci.yaml</code> file. Then, the <code>parents</code> stage will use this file and will run the necessary stages to update deployment configuration with the matching GitLab‚Äôs environment variables.</p>\n<p>This is the <a href=\"https://pypi.org/project/Jinja2/\">Jinja</a> template we‚Äôre using:</p>\n<pre><code class=\"language-yaml\">\nimage: gitlab.locsec.net:4567/cloudmta/threatcloud-mta-infra/ci-image:latest\n# https://docs.gitlab.com/ee/ci/yaml/index.html#switch-between-branch-pipelines-and-merge-request-pipelines\nworkflow:\n  rules:\n    - if: $CI_COMMIT_BRANCH &#x26;&#x26; $CI_OPEN_MERGE_REQUESTS &#x26;&#x26; $CI_PIPELINE_SOURCE == \"push\"\n      when: never\n    - when: always\n\nvariables:\n  PY_COLORS: '1'\n  GIT_SUBMODULE_STRATEGY: recursive\n\nstages:\n{% for environment in environments.keys() %}\n  - \"validate:{{ environment }}:{{ stage_params[1:] |join('-') }}\"\n  - \"deploy:{{ environment }}:{{ stage_params[1:] |join('-') }}\"\n{% endfor %}\n\n{% for stage in [\"validate\", \"deploy\"] %}\n{% for environment, regions in environments.items() %}\n{% for region in regions %}\n{{ stage }}:{{ resource }}:{{ environment }}:{{ region }}:{{ stage_params[1:] |join('-') }}:\n{% if stage == \"deploy\" %}\n  rules:\n    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n      when: never\n{% if ci_project_name == \"app-infra\" %}\n    - when: manual\n{% else %}\n    - when: on_success\n{% endif %}\n  environment:\n    name: {{ stage_params[1:] |join('-') }}/{{ resource }}/{{ environment }}/{{ region }}\n{% endif %}\n  variables:\n    AWS_ACCESS_KEY_ID: ${{ region | upper | replace(\"-\", \"_\") }}_{{ environment | upper }}_STS_KEY\n    AWS_SECRET_ACCESS_KEY: ${{ region | upper | replace(\"-\", \"_\") }}_{{ environment | upper }}_STS_SECRET\n    CLUSTER_NAME: {{ region }}-{{ \"prd\" if environment == \"prod\" else environment }}\n    K8S_NAMESPACE: group-{{ \"dev\" if environment == \"stg\" else environment }}\n    AWS_REGION: {{ region }}\n  stage: {{ stage }}:{{ environment }}:{{ stage_params[1:] |join('-') }}\n  allow_failure: false\n  script:\n{% if ci_project_name != \"app-infra\" %}\n    - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.locsec.net/group/app-infra.git\n    - cd app-infra\n{% endif %}\n    - aws --region $AWS_REGION eks update-kubeconfig --name $CLUSTER_NAME\n    - kubectl config set-context --current --namespace=$K8S_NAMESPACE\n    - python3 scripts/apply_k8s.py --file {{ file }} --resource {{ resource }} --environment {{ environment }} --region {{ region }} --stage {{ stage }}\n{% endfor %}\n{% endfor %}\n{% endfor %}\n</code></pre>\n<p>You can see in the example where the ‚Äúmagic‚Äù is hidden. In the <code>variables</code> section we have our AWS environment variable, which is needed to deploy our app to the EKS cluster. This environment is built from the template <code>${{ region | upper | replace(‚Äú-‚Äù, ‚Äú_‚Äù) }}_{{ environment | upper }}_STS_KEY</code>.</p>\n<p>Here is an output example from this template:</p>\n<pre><code class=\"language-yaml\">\nimage: gitlab.locsec.net:4567/cloudmta/threatcloud-mta-infra/ci-image:latest\n# https://docs.gitlab.com/ee/ci/yaml/index.html#switch-between-branch-pipelines-and-merge-request-pipelines\nworkflow:\n  rules:\n    - if: $CI_COMMIT_BRANCH &#x26;&#x26; $CI_OPEN_MERGE_REQUESTS &#x26;&#x26; $CI_PIPELINE_SOURCE == \"push\"\n      when: never\n    - when: always\nvariables:\n  PY_COLORS: '1'\n  GIT_SUBMODULE_STRATEGY: recursive\n\nstages:\n  - \"validate:stg:app-config-service\"\n  - \"deploy:stg:app-config-service\"\n  - \"validate:prod:app-config-service\"\n  - \"deploy:prod:app-config-service\"\n\n\n\nvalidate:deployment:stg:eu-west-1:app-config-service:\n  variables:\n    AWS_ACCESS_KEY_ID: $EU_WEST_1_STG_STS_KEY\n    AWS_SECRET_ACCESS_KEY: $EU_WEST_1_STG_STS_SECRET\n    CLUSTER_NAME: eu-west-1-group-stg\n    K8S_NAMESPACE: group-stg\n    AWS_REGION: eu-west-1\n  stage: validate:stg:app-config-service\n  allow_failure: false\n  script:\n    - aws --region $AWS_REGION eks update-kubeconfig --name $CLUSTER_NAME\n    - kubectl config set-context --current --namespace=$K8S_NAMESPACE\n    - python3 scripts/apply_k8s.py --file k8s/app-config-service/deployment.yaml --resource deployment --environment stg --region eu-west-1 --stage validate\n\nvalidate:deployment:prod:us-east-1:app-config-service:\n  variables:\n    AWS_ACCESS_KEY_ID: $US_EAST_1_PROD_STS_KEY\n    AWS_SECRET_ACCESS_KEY: $US_EAST_1_PROD_STS_SECRET\n    CLUSTER_NAME: us-east-1-group-prd\n    K8S_NAMESPACE: group-prod\n    AWS_REGION: us-east-1\n  stage: validate:prod:app-config-service\n  allow_failure: false\n  script:\n    - aws --region $AWS_REGION eks update-kubeconfig --name $CLUSTER_NAME\n    - kubectl config set-context --current --namespace=$K8S_NAMESPACE\n    - python3 scripts/apply_k8s.py --file k8s/app-config-service/deployment.yaml --resource deployment --environment prod --region us-east-1 --stage validate\n\n\ndeploy:deployment:stg:eu-west-1:app-config-service:\n  rules:\n    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n      when: never\n    - when: manual\n  environment:\n    name: app-config-service/deployment/stg/eu-west-1\n  variables:\n    AWS_ACCESS_KEY_ID: $EU_WEST_1_STG_STS_KEY\n    AWS_SECRET_ACCESS_KEY: $EU_WEST_1_STG_STS_SECRET\n    CLUSTER_NAME: eu-west-1-group-stg\n    K8S_NAMESPACE: group-dev\n    AWS_REGION: eu-west-1\n  stage: deploy:stg:app-config-service\n  allow_failure: false\n  script:\n    - aws --region $AWS_REGION eks update-kubeconfig --name $CLUSTER_NAME\n    - kubectl config set-context --current --namespace=$K8S_NAMESPACE\n    - python3 scripts/apply_k8s.py --file k8s/app-config-service/deployment.yaml --resource deployment --environment stg --region eu-west-1 --stage deploy\n\ndeploy:deployment:prod:us-east-1:app-config-service:\n  rules:\n    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n      when: never\n    - when: manual\n  environment:\n    name: app-config-service/deployment/prod/us-east-1\n  variables:\n    AWS_ACCESS_KEY_ID: $US_EAST_1_PROD_STS_KEY\n    AWS_SECRET_ACCESS_KEY: $US_EAST_1_PROD_STS_SECRET\n    CLUSTER_NAME: us-east-1-group-prd\n    K8S_NAMESPACE: group-prod\n    AWS_REGION: us-east-1\n  stage: deploy:prod:app-config-service\n  allow_failure: false\n  script:\n    - aws --region $AWS_REGION eks update-kubeconfig --name $CLUSTER_NAME\n    - kubectl config set-context --current --namespace=$K8S_NAMESPACE\n    - python3 scripts/apply_k8s.py --file k8s/app-config-service/deployment.yaml --resource deployment --environment prod --region us-east-1 --stage deploy\n</code></pre>\n<p>Adding a new region, to deploy all our microservices, is as easy as adding a Gitlab‚Äôs group environment variable!</p>\n<p>This is how the pipeline will look on the centralize k8s configuration project:</p>\n<p><img src=\"https://miro.medium.com/max/875/1*lG8gvALfRfZRNmPPlcZuuw.png\" alt=\"\"></p>\n<p>dynamic child pipelines</p>\n<p>From each project, we‚Äôll use this stages to deploy only the specific microservice:</p>\n<pre><code class=\"language-yaml\">\ncreate deploy to dedicated prod:\n  stage: pre-prod-deploy\n  image: gitlab.locsec.net:4567/group/app-infra/ci-image:latest\n  script:\n    - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.locsec.net/group/app-infra.git\n    - cd app-infra\n    - python3 scripts/generate_ci.py\n    - cp -r ci-out ..\n  artifacts:\n    paths:\n      - ci-out\n  except:\n    refs:\n      - schedules\n  only:\n    refs:\n      - master\n\n\ndeploy to dedicated prod:\n  stage: prod-deploy\n  variables:\n    PARENT_PIPELINE_ID: $CI_PIPELINE_ID\n    PARENT_JOB_NAME: \"create deploy to dedicated prod\"\n  trigger:\n    include:\n      - artifact: ci-out/middle-ci.yml\n        job: \"create deploy to dedicated prod\"\n    strategy: depend\n  when: on_success\n  except:\n    refs:\n      - schedules\n  only:\n    refs:\n      - master\n</code></pre>\n<p>That‚Äôs it. we can now easily maintain our k8s configurations, our deployment CI and initiate new regions.</p>\n<h1>Conclusion</h1>\n<p>In this post I continued describing how GitLab CI helps us with our app growth. I tried to keep it as simple as possible, but if something is not clear enough, feel free to contact me with any question you have.</p>\n<p>I hope you found this tutorial helpful. Thanks for reading!</p>\n<blockquote>\n<p>Thanks a lot to <a href=\"https://medium.com/@israelst11\">Israelst</a> for reviewing this post</p>\n</blockquote>"}},{"node":{"frontmatter":{"title":"","emoji":null,"subtitlePrefix":null,"subtitleHighlight":null,"subtitleSuffix":null,"slug":null},"html":"<h1>CI/CD of microservices architecture with GitLab</h1>\n<h2>How we made our microservices continuous integration &#x26; delivery process easily maintained</h2>\n<blockquote>\n<p>This is a re-publish for a post I wrote back in Aug 2019. many things changed since then and I hope to write new post about it soon</p>\n</blockquote>\n<p>As the Threat Cloud Application team, we‚Äôre responsible for many cloud applications. We have public applications, and many other internal applications that support them. This software design is also known as a microservices architecture. Our applications are deployed on Kubernetes cluster which is deployed in AWS.</p>\n<p>We started using GitLab as our central source code management and application life cycle about a year ago.</p>\n<p>In this post I‚Äôll describe our evolution of understanding how to work with GitLab in order to easily maintain the life cycle of our microservices.</p>\n<h1>What we had when we began</h1>\n<p>When we joined our internal hosted GitLab our main focus was to simply import all of our code base from a simple git server to GitLab. We didn‚Äôt fully invest in exploring the many ways GitLab can help us in the development cycle and the CI/CD process.</p>\n<p>It wasn‚Äôt long before we began designing our CI/CD process, but even then we didn‚Äôt fully capitalize the GitLab features and our .gitlab-ci.yml looked like this:</p>\n<pre><code class=\"language-yaml\">image: docker:latest\nservices:\n- docker:dind\n\nstages:\n- build\n- integration-test\n- push\n- dev-deploy\n- prod-deploy\n\n# Cache downloaded dependencies and plugins between builds.\ncache:\n  paths:\n  - .m2/repository\n  key: \"$CI_JOB_NAME\"\n\nvariables:\n  CONTAINER_RELEASE_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA\n  CONTAINER_RELEASE_IMAGE_LATEST: $CI_REGISTRY_IMAGE:latest\n  DEV_KUBECTL_CONFIG: $k8s_deploy_config_kube1\n  EU_PROD_KUBECTL_CONFIG: $k8s_deploy_config_eu_west_1_kube2\n  US_PROD_KUBECTL_CONFIG: $k8s_deploy_config_us_east_1_kube1\n  MAVEN_OPTS: \"-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository\"\n\n\nmaven-build:\n  image: snirnx/docker-maven:3.5.4\n  stage: build\n  script:\n  - \"sh ci_scripts/run_build.sh dev jar\"\n  except:\n    - master\n\nmaven-build-master:\n  image: snirnx/docker-maven:3.5.4\n  stage: build\n  script:\n  - \"sh ci_scripts/run_build.sh master jar\"\n  only:\n    - master\n\nintegration:\n  image: snirnx/docker-maven:3.5.4\n  stage: integration-test\n  script:\n    - \"bash ci_files/integration_test.sh $CI_COMMIT_SHA\"\n  artifacts:\n    name: \"CI_COMMIT_SHA-results\"\n    when: always\n    expire_in: 4 days\n    paths:\n      - reputation-service-integration-tests/target/site/\n      - reputation-service-integration-tests/log/\n  tags:\n    - reputation-integration-tests\n\n\ndevelopment-deploy:\n  stage: dev-deploy\n  image: snirnx/kubectl:v1.8.6\n  script:\n  - \"sh ci_scripts/deploy.sh dev eu\"\n  only:\n  - master\n\nproduction-deploy:\n  stage: prod-deploy\n  image: snirnx/kubectl:v1.8.6\n  script:\n  - \"sh ci_scripts/deploy.sh prod us\"\n  - \"sh ci_scripts/deploy.sh prod eu\"  \n  only:\n  - master\n  when: manual\n</code></pre>\n<p>As we can see, the pipeline was depend fully on old-style bash scripts.</p>\n<pre><code class=\"language-bash\">ENV=$1\nAPP=$2\nPACKAGE=$3\n\nmvn clean install\nrc=$?\nif [[ $rc -ne 0 ]]; then\n  echo \"Maven build failed\"; exit $rc\nfi\n\ncp target/$APP.$PACKAGE docker/\n\ndocker build -t $APP docker/\n\ndocker images\n\n#echo \"docker login\"\ndocker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\n\necho \"docker tag\"\ndocker tag $APP $CI_REGISTRY_IMAGE/$APP:$CI_COMMIT_SHA\nif [[ \"$ENV\" != \"dev\" ]]; then\n    docker tag $APP $CI_REGISTRY_IMAGE/$APP:latest\nfi\n\n#echo \"docker push\"\ndocker push $CI_REGISTRY_IMAGE/$APP:$CI_COMMIT_SHA\nif [[ \"$ENV\" != \"dev\" ]]; then\n    docker push $CI_REGISTRY_IMAGE/$APP:latest\nfi\n\nrc=$?\nif [[ $rc -ne 0 ]]; then\n  echo \"Failed to push to regsitry $APP\"; exit $rc\nfi\n\n\necho \"Pushed build '$CI_REGISTRY_IMAGE/$APP:$CI_COMMIT_SHA'\"\n</code></pre>\n<p>One big downside of using this kind of scripts inside .gitlab-ci.yml job was that we needed to handle exit code of each ourselves, or else the job won‚Äôt fail when one step is failed. Other downside was that GitLab didn‚Äôt highlight each step from within a single script, so we needed to handle it ourselves using echo commands.</p>\n<p>The only thing we considered as an advantage was the ability to copy the generic bash script between the different projects, allowing our developers to focus on the code of the new microservice application and not on the CI process. Or so we thought. But what happen when you want to improve something in your CI bash scripts? Add a new feature? Going over ~30 repositories is not an easy thing.</p>\n<p>One solution was to keep one scripts project in GitLab with all the bash scripts allowing each project to clone and use the script it requires. Even though this is good enough solution, we knew there had to be more native GitLab way to handle centralize CI/CD pipeline.</p>\n<h1>What we have now</h1>\n<p>We start using a feature introduced as a Premium feature on the GitLab 10.5 and moved to GitLab core on 11.4 release. The feature is called include.</p>\n<blockquote>\n<p>Using the include keyword, you can allow the inclusion of external YAML file</p>\n</blockquote>\n<p>With this feature our .gitlab-ci.yml looks like this:</p>\n<pre><code class=\"language-yaml\">image: docker:latest\nservices:\n  - docker:dind\n\nstages:\n  - build\n  - integration-test\n  - pre-dev-deploy\n  - dev-deploy\n  - continue-to-prod\n  - pre-prod-deploy\n  - prod-deploy\n  - post-deploy\n\n# Cache downloaded dependencies and plugins between builds.\ncache:\n  paths:\n    - .m2/repository\n  key: \"$CI_JOB_NAME\"\n\nvariables:\n  IMAGE_NAME: \"image-name\"\n  DOCKER_FILE_DIR: docker/\n  K8S_DEV_CONFIGMAP: \"\"\n  K8S_PROD_CONFIGMAP: \"\"\n  K8S_DEV_DEPLOYMENT: \"k8s/dev/deployment.yaml\"\n  K8S_PROD_DEPLOYMENT: \"k8s/prod/deployment.yaml\"\n\ninclude:\n  - project: \"ThreatCloud/centralize-reputation-pipeline\"\n    file: .gitlab-ci-build-mvn.yml\n  - project: \"ThreatCloud/centralize-reputation-pipeline\"\n    file: .gitlab-ci-integration.yml\n  - project: \"ThreatCloud/centralize-reputation-pipeline\"\n    file: .gitlab-ci-deploy.yml\n  - project: \"ThreatCloud/centralize-reputation-pipeline\"\n    file: .gitlab-ci-post.yml\n\n</code></pre>\n<p>The first thing we did was to define what stages we wanted to be included in our pipeline for all our applications:</p>\n<ul>\n<li><strong>Build</strong> ‚Äî Run unit tests, dockerize the service and also test that the yamls of the deployments are valid</li>\n<li><strong>Integration Tests</strong> ‚Äî Run the integration test for each service</li>\n<li><strong>Pre Staging deployment</strong> ‚Äî Things needed to be deployed in the staging k8s before deploying the actual service, e.g. configmap</li>\n<li><strong>Staging deployment</strong> ‚Äî Deploying the service to staging k8s</li>\n<li><strong>Pre Production deployment</strong> ‚Äî Things needed to be deployed in the production k8s before deploying the actual service, e.g. configmap</li>\n<li><strong>Production deployment</strong> ‚Äî Deploying the service to production k8s</li>\n<li><strong>Post Production deployment</strong> ‚Äî Things we‚Äôre doing after each production deployment, e.g. notify to slack about the deployment and release changes</li>\n</ul>\n<p>Then we built .gitlab-ci.yml files for all steps. We made sure to keep it generic so that only by using different variables defined in each project the pipeline would work as expected.</p>\n<p>Now we can enjoy a native GitLab CI execution and highlight in all of our jobs. We can easily add new features to each step and automatically all the projects will start enjoying it automatically. The developer doesn‚Äôt need to deal with the CI/CD process and can focus solely on writing new code. All he needs to do is to copy the .gitlab-ci.yml, change a few variable and that‚Äôs it, the pipeline works.</p>\n<h1>Conclusion</h1>\n<p>In this post I tried, as simple as possible, to describe the process we went through to successfully maintain our CI/CD pipelines with GitLab. I‚Äôm sure that there are other solutions and ways that GitLab can help improve an application life cycle.</p>\n<p>I hope that you found this tutorial helpful. Thanks for reading!</p>\n<blockquote>\n<p>To see how we further improved our CI/CD process with GitLab, check out <a href=\"https://medium.com/@aviadlevy/ci-cd-of-microservices-architecture-with-gitlab-pt-2-f640d4c57c9b\">part 2</a></p>\n</blockquote>"}},{"node":{"frontmatter":{"title":"","emoji":null,"subtitlePrefix":null,"subtitleHighlight":null,"subtitleSuffix":null,"slug":null},"html":"<h2>How to Install go-yara Library on Windows</h2>\n<p>Go-Yara (github.com/hillu/go-yara/v4) is a powerful Go (Golang) library that allows you to work with YARA rules and scan files for patterns and signatures efficiently. In this guide, we will walk you through the steps required to install the go-yara library on a Windows machine using MSYS2 and MinGW.</p>\n<h2>Prerequisites</h2>\n<p>Before we begin, make sure you have the following prerequisites installed on your Windows machine:</p>\n<ol>\n<li>\n<p>MSYS2: You can download the MSYS2 installer from the official website and follow the installation instructions provided there.</p>\n</li>\n<li>\n<p>Go: Make sure you have Go (Golang) installed on your machine. You can download the latest version of Go from the official website.</p>\n</li>\n</ol>\n<h2>Installation Steps</h2>\n<h3>Step 1: Install required packages</h3>\n<p>Open the MSYS2 MinGW 64-bit terminal and run the following command to install the necessary packages:</p>\n<pre><code>pacman -S mingw-w64-x86_64-toolchain mingw-w64-x86_64-gcc mingw-w64-x86_64-make mingw-w64-x86_64-pkg-config base-devel openssl-devel autoconf-wrapper automake libtool\n</code></pre>\n<h3>Step 2: Download YARA source code</h3>\n<p>Download the YARA source code from the official GitHub repository at: <a href=\"https://github.com/VirusTotal/yara/releases\">https://github.com/VirusTotal/yara/releases</a></p>\n<h3>Step 3: Build and Install YARA</h3>\n<p>Navigate to the YARA source code directory using the MSYS2 terminal:</p>\n<pre><code>cd /path/to/yara-source-code\n</code></pre>\n<p>Next, run the following commands to build and install YARA:</p>\n<pre><code>./bootstrap.sh\n./configure\nmake\nmake install\n</code></pre>\n<h3>Step 4: Add MinGW to Path</h3>\n<p>To ensure that everything works smoothly, you need to add the MinGW binaries directory to your system‚Äôs Path. By default, MinGW is installed at C:\\msys64\\mingw64\\bin. Add this path to your system's environment variables.</p>\n<h3>Step 5: Run your application</h3>\n<p>Now you can run your application from any command line or IDE directly (you don‚Äôt need to use MinGW anymore).</p>\n<p>To make the go-yara library work correctly, you need to set the CGO_ENABLED and GOARCH environment variables. Open your system's Environment Variables settings and add the following entries:</p>\n<pre><code>export CGO_ENABLED=1\nexport GOARCH=amd64\n</code></pre>\n<p>When running your application you should use following command:</p>\n<pre><code>go build -ldflags \"-extldflags=-static\" -tags yara_static main.go\n</code></pre>\n<h2>Test the Installation</h2>\n<p>To verify that go-yara is correctly installed on your system, you can create a simple Go program that uses the library to run a YARA rule. Here‚Äôs a basic example:</p>\n<pre><code>package main\n\nimport (\n \"fmt\"\n\n \"github.com/hillu/go-yara/v4\"\n)\n\nfunc main() {\n c, err := yara.NewCompiler()\n if c == nil || err != nil {\n  fmt.Println(\"Error to create compiler:\", err)\n  return\n }\n rule := `rule test {\n    meta: \n     author = \"Aviad Levy\"\n    strings:\n     $str = \"abc\"\n    condition:\n     $str\n   }`\n if err = c.AddString(rule, \"\"); err != nil {\n  fmt.Println(\"Error adding YARA rule:\", err)\n  return\n }\n r, err := c.GetRules()\n if err != nil {\n  fmt.Println(\"Error getting YARA rule:\", err)\n  return\n }\n var m yara.MatchRules\n err = r.ScanMem([]byte(\" abc \"), 0, 0, &#x26;m)\n if err != nil {\n  fmt.Println(\"Error matching YARA rule:\", err)\n  return\n }\n fmt.Printf(\"Matches: %+v\", m)\n}\n</code></pre>\n<p>Save this code to a file (e.g., main.go). Then, run the program using the go run command:</p>\n<pre><code>go run -ldflags \"-extldflags=-static\" -tags yara_static main.go\n</code></pre>\n<p>If everything is set up correctly, you should see the matched YARA rule printed on the screen.</p>\n<h2>Conclusion</h2>\n<p>Congratulations! You‚Äôve successfully installed the go-yara library on your Windows machine and verified its functionality with a simple YARA rule scanning example. With this library, you can now take advantage of YARA‚Äôs powerful pattern matching capabilities in your Go projects.</p>\n<p>For more information and detailed documentation on go-yara, be sure to check out the official GitHub repository:\n<a href=\"https://github.com/hillu/go-yara\"><strong>GitHub - hillu/go-yara: Go bindings for YARA</strong>\n*Go bindings for YARA. Contribute to hillu/go-yara development by creating an account on GitHub.*github.com</a></p>\n<p>I hope that you found this guide helpful. Thanks for reading!</p>"}},{"node":{"frontmatter":{"title":"","emoji":null,"subtitlePrefix":null,"subtitleHighlight":null,"subtitleSuffix":null,"slug":null},"html":"<h1>blog-posts</h1>\n<p>This is a backup for my  blog post until I'll have the time to open my personal GitHub pages</p>"}},{"node":{"frontmatter":{"title":"Hello","emoji":"üëã","subtitlePrefix":"I'm ","subtitleHighlight":"Aviad Levy","subtitleSuffix":"","slug":"home"},"html":"<h2>Software Engineer who loves to code!</h2>"}},{"node":{"frontmatter":{"title":"Plant Generator","emoji":"üå±","subtitlePrefix":"The tool that will make you look","subtitleHighlight":"smart","subtitleSuffix":"while you travel","slug":"plant-generator"},"html":"<iframe src=\"https://aviadlevy.github.io/plant-generator\" width=\"100%\" height=\"450\"></iframe>"}}]}},"pageContext":{}},"staticQueryHashes":["1947816842","2841359383"]}